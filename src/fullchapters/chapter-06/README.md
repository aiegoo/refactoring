# 기본적인 리팩토링

> 내가 가장 많이 사용하는 리팩토링은 함수 추출하기와 변수 추출하기 이다. 리팩터링은 본래 코드를 변경하는 작업인 만큼, 이 두 리팩터리은 반대로 진행하는 함수 인라인하기와 변수 인라인하기도 자주 사용한다.

> 함수 구성과 이름 짓기는 가장 기본적인 저수준 리팩터링이다. 그런데 일단 함수를 만들고 나면 다시 고수준 모듈로 묶어야 한다. 이렇게 함수를 그룹으로 묶을 때는 여러 함수를 클래스로 묶기를 이용한다. 


## table of contents
- 함수 추출하기
- 함수 인라인하기

- [part.6](#part.6)


## 함수 추출하기

### 배경
> 함수 추출하기는 내가 가장 많이 사용하는 리팩터링 중 하나다. 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다. 

코드 조각을 찾아 무슨일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.

### 독립된 함수로 코드를 묶어야 할 때
코드를 언제 독립된 함수로 묶어야 할지에 관한 의견은 수없이 많다.
하지만 내 눈에는 목적과 구현을 분리하는 방식이 가장 합리적인 기준으로 보인다. 코드를 보고, 무슨 일을 하는지 파악하는 데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 무슨 일에 걸맞는 이름을 짓는다. 이렇게 해두면 나중에 코드를 다시 읽을 때 함수의 목적이 눈에 확 들어오고, 본문 코드에 대해서는 더 이상 신경 쓸 일이 거의 없다.

**목적(강조)과 구현(반전)을 분리하는 방식**


함수를 짧게 만들면 함수 호출이 많아져서 성능이 느려질까 걱정하는 사람도 있다. 내가 젊던 시절에는 간혹 문제가 되긴 했지만 요즘은 그럴 일이 거의 없다. 함수가 짧으면 캐싱하기가 더 쉽기 때문에 컴파일러가 최적화하는 데 유리할 때가 많다. 성능 최적화에 대해서는 항상 일반적인 지침을 따르도록 하자.  
**짧은 함수의 이점은 이름을 잘 지어야만 발휘**되므로 이름 짓기에 특별히 신경써야 한다. 이름을 잘 짓기까지는 어느 정도 훈련이 필요하다. 하지만 일단 요령을 터득한 후에는 별도 문서 없이 코드 자체만으로 내용을 충분히 설명되게 만들 수 있다.   
긴 함수에는 각각의 코드 덩어리 첫머리에 그 목적을 설명하는 주석이 달려있을 때가 많다. 해당 코드 덩어리를 추출한 함수의 이름을 지을 때 이 주석을 참고하면 도움이 될 것이다.  


#### 최적화에 대한 일반적인 지침
**첫째.** 하지마라
**둘째.** (전문가 한정). 아직 하지 마라.




### 오리지널 스몰토크 시스템



## part.6


## 6.7 변수 이름 바꾸기(Rename Variable)
명확한 프로그래밍의 이름은 핵심짓기다. 변수는 프로그래머가 하려는 일에 관해 많은 것을 설명해준다.

```js
let a = height * width;

// change name
let area = height * width;
```



### 절차
1. 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려한다.
1. 이름을 바꿀 변수를 참조하는 곳을 찾아서, 하나씩 변경한다.
  - 다른 코드베이스에서 참조하는 변수는 외부에 공개된 변수이므로 이 리팩터링을 적용할 수 없음
  - 변수 값이 변하지 않는다면 다른 이름으로 복제본을 만들어서 점진적으로 변경한다. 하나씩 바꿀 때마다 테스트
1. 테스트 한다.



### 변수 캡슐화하기
임시 변수나 인수처럼 유효범위가 함수 하나로 국한된 변수는 그저 변수를 참조하는 코드를 찾아서 하나씩 바꾸면 되며, 다 바꾼 뒤에는 테스트해서 실수한 부분은 없는지 확인한다.

#### 예시

```js
let tpHd = 'untitled';

// 어떤 참조는 변수를 읽기만 하고,
result += '<h1>${tpHd}</h1>'
// 값을 수정하는 곳도 있다고 할 경우
tpHd = obj['articleTitle']
```

#### 변수 캡슐화하기

```js
result += '<h1>${title()}</h1>'

// 값을 수정하는 곳도 있다고 할 경우
// tpHd = obj['articleTitle']
setTitle(obj['articleTitle'])

const title = () => tpHd; // tpHd 변수의 게터
const setTitle = arg => tpHd = arg; // tpHd 변수의 세터
```



#### 예시: 상수 이름 바꾸기
상수의 이름은 캡슐화하지 않고도 복제방식으로 점진적으로 바꿀 수 있다.
상수가 다음처럼 선언되어 있을 경우

```js
const cpyNm = '애크미 구스베리'
```

1. 먼저 원본의 이름을 바꾼 후
1. 원본의 원래 이름과 같은 복제본을 만든다.

```js
const companyName = '애크미 구스베리'
const cpyNm = companyName
```


## 6.8 매개변수 객체 만들기(Introduce Parameter Object)
배경  
데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우를 자주 본다. 나는 이런 데이터 무리를 발견하면 데이터 구조 하나로 모아주곤 한다.

```js
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
```

데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다. 게다가 함수가 이 데이터 구조를 받게 하면 매개변수 수가 줄어든다. 

```js
function amountInvoiced(aDataRange) {...}
function amountReceived(aDataRange) {...}
```


### 절차
1. 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.
1. 테스트한다.
1. 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
1. 테스트한다.
1. 함수 호출시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
1. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
1. 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.


### 예시: 진정한 값 객체로 거듭나기
매개변수 그룹을 객체로 교체하는 일은 진짜 값진 작업의 준비단계일 뿐이다. 앞에서처럼 클래스로 만들어두면 관련 동작들을 이 클래스로 옮길 수 있다는 이점이 생긴다. 이 예에서는 온도가 허용 범위 안에 있는지 검사하는 메서드를 클래스에 추가할 수 있다.

```js
function readingsOutsideRange(station, range) {
  return station.readings.filter(r => !range.contains(r.temp));
}

class NumberRange {
  constructor(min, max) {
    this._data = { min: min, max: max };
  }
  get min() {
    return this._data.min;
  }
  get max() {
    return this._data.max;
  }

  contains(aNumber) {
    return aNumber >= this.min && aNumber <= this.max;
  }
}

```

지금까지 한 작업은 여러 가지 유용한 동작을 갖춘 범위(Range) 클래스를 생성하기 위한 첫 단계다. 코드에 범위 개념이 필요함을 깨달았다면 최댓값과 최솟값 쌍을 사용하는 코드를 발견할 때마다 범위 객체로 바꾸자(). 이러한 값 쌍이 어떻게 사용되는지 잘 살펴보면 다른 유용한 동작도 범위 클래스로 옮겨서 코드베이스 전반에서 값을 활용하는 방식을 간소화할 수 있다. 나라면 진정한 값 객체로 만들기 위해 값에 기반한 동치성 검사 메서드부터 추가할 것이다.


## 6.9 여러 함수를 클래스로 묶기

```js
function base(aReading) { ... }
function taxableCharge(aReading) { ... }
function calculateBaseCharge(aReading) { ... }
```

```js
class Reading {
  base() {...}
  taxableCharge() {...}
  calculateBaseCharge() {...}
}
```

### 배경

클래스는 대다수의 최신 프래그래밍 언어가 제공하는 기본적인 빌딩 블록이다. 클래스는 데이터와 함수를 하나의 공유환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다. **클래스는 객체 지향 언어의 기본인 동시에 다른 패러다임 언어에도 유용**하다.

- 클래스를 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다.
- 클래스로 묶을 때 두드러진 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파싱 객체들을 일관되게 관리할 수 있다는 것이다.
- 나는 중첩 함수보다 클래스르 선호하는 편인데, 중첩 함수는 테스트하기가 까다로울 수 있기 때문이다.

### 절차
1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다.
  - 공통 데이터가 레코드 구조로 묶여 있지 않다면, 매개변수 객체 만들기로 데이터를 하나로 묶는 레코드를 만든다.
1. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다. 
  - 공통 레코드의 멤버는 함수 호출문의 인수 목록에서 제거한다.
1. 데이터를 조가하는 로직들은 함수로 호출해서 새 클래스로 옮긴다.



## 6.10 여러 함수를 변환 함수로 묶기

```js
function base(aReading) {...}
function taxableCharge(aReading) {...}
```


```js
function enrichReading(argReading) {
  const aReading = _.cloneDeep(argReading);
  aReading.baseCharge = base(aReading);
  aReading.taxableCharge = taxableCharge(aReading);
  return aReading;
}

```


### 배경
소프트웨어는 데이터를 입력받아서 여러 가지 정보를 도출하곤 한다. 이렇게 도출된 정보는 여러 곳에서 사용될 수 있는데, 그러다 보면 이 정보가 사용되는 곳마다 같은 도출 로직이 반복되기도 한다. 나는 이런 도출 작업을들 한데로 모아두길 좋아한다. **모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고, 로직 중복도 막을 수 있다.**


- 여러 함수를 변환 함수로 묶기 대신 여러 함수를 클래스로 묶기(6.9절)로 처리해도 된다. 어느 것을 사용해도 좋으며, 나는 대체로 이미 반영된 프로그래밍 스타일을 따르는 편이다.
- 그런데, 둘 사이에는 중요한 차이가 하나 있다. 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다. 변환 함수로 묶으면 가공한 데이터를 새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있기 때문이다.
- 여러 함수를 한데 묶는 이유는 **도출 로직이 중복되는 것을 피하기 위해서다.** 이 로직을 함수로 추출하는 것만으로도 같으 효과를 볼 수 있지만, 데이터 구조와 이를 사용하는 함수가 근처에 있지 않으면 함수를 발견하기 어려울 때가 많다.


### 절차 
1. 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다.
1. 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.
1. 테스트한다.
1. 나머지 관련 함수도 위 과정에 따라 처리한다.


- 얕은 복사는 1단계에서만 한다.

- 
- pass by value

## 6.11 단계 쪼개기

```js
const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split('-')[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;
```

```js
const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList)

function parseOrder(aString) {
  const values = aString.split(/\s+/);
  return ({
    productID: values[0].split('-')[1],
    quantity: parseInt(values[1]),
  });
}
function price(order, priceList) {
  return order.quantity * priceList[order.productID];
}

```

### 배경
> 마틴 파울러 - 나는 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다. 코드를 수정해야 할 때 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위해서다. 모듈이 잘 분리되어 있다면 다른 모듈의 상세 내용은 전혀 기억하지 못해도 원하는 대로 수정을 끝마칠 수도 있다. 



### 절차
1. 두 번째 단계에 해당하는 코드를 독립함수로 추출한다.
1. 테스트한다. 
1. 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
1. 테스트한다.
1. 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다. 그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다.
  - 간혹 두 번째 단계에서 사용하면 안되는 매개변수가 있다. 이럴 때는 각 매개변수 사용한 결과를 중간 데이터 구조의 필드로 추출하고, 이 필드의 값을 설정하는 문장을 호출한 곳으로 옮긴다.
1. 첫 번째 단계 코드를 함수로 추출하면서, 중간 데이터 구조를 반환하도록 만든다.
  - 이때 첫 번째 단계를 변환기 객체로 추출해도 좋다.




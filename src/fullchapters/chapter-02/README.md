# chapter.2 리팩터링 원칙

## table of contents
1. 리팩터링 정의
1. 두 개의 모자
1. 리팩터링하는 이유
1. 언제 리팩터링해야 할까?
1. 리팩터링시 고려할 문제

---


## 리팩터링 정의
리팩퍼링이란 용어의 엄격한 정의
- 리팩터링: [명사]소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 리팩터링(하다): [동사]소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 

누군가 "리팩토링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다. 


## 두 개의 모자
> 나는 소프트웨어를 개발할 때 목적이 '기능 추가'냐 아니면 '리팩터링'이냐를 명확히 구분해 작업한다. 캔트 벡은 이를 두 개의 모자에 비유했다. 기능을 추가할 때는 '기능 추가' 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다. 반면 '리팩터링'모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.
> 소프트웨어를 개발하는 동안 나는 두 모자를 자주 바꿔 쓴다. 
> 전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.


## 리팩터링하는 이유
리팩터링은 소프트웨어의 문제를 해결하는 만병통치약은 아니지만 코드를 건강한 상태로 도와주는 약이다.

### 리팩터링하면 소프트웨어 설계가 좋아진다.


### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.


### 리팩터링하면 버그를 쉽게 찾을 수 있다. 


### 리팩터링하면 프로그래밍 속도를 높일 수 있다.
- 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있음
- 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 됨
- 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉬움
- 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 토대가 됨


## 언제 리팩터링해야 할까?

### 3의 법칙
1. 처음에는 그냥 한다.
1. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
1. 비슷한 일을 세번 하게 되면 리팩터링한다.

> 야구를 좋아하는 사람은 '스트라이크 세 번이면 리팩터링하라'로 기억하자.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
- 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
- 리팩터링 모자를 쓰고, **함수 매개변수화**하기를 적용한다. 그러고 나면 함수에 필요한 매개변수를 지정해서 호출하기만 하면 된다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
- 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다. 코드를 파악할 때마다 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. 
- 조건부 로직의 구조가 이상하지는 않은지, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지 않는지 살펴본다. 
- 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누기도 한다. 그러면 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다. 이 모든 변경을 머릿속으로 시뮬레이션 해볼 만큼 내 머리가 좋지 않기 때문에 코드를 정리하지 않았다면 영원히 보지 못하고 지나쳤을지도 모를 것들이다.

> 워드 커닝햄이 말하길 리팩터링하면 머리로 이해한 것을 코드에 옮겨담을 수 있다.

### 쓰레기 줍기 리팩터링
- 로직이 쓸데 없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 많은 시간을 뺏기긴 싫을테니 이 때 절충을 통해 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.

### 계획된 리팩터링과 수시로 하는 리팩터링
- 앞에서 본 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가 될 때만 진행한다. 
- 나는 개발에 들어가기 전에 리팩터링 일정을 따로 잡지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다. 프로그래밍 과정에 자연스럽게 녹인 것이다.
- 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에도 도움을 준다.

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.  
- 리팩터링은 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다. 물론 보기 싫은 코드는 리팩터링해야 함은 당연하지만 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다.), 그런 다음 쉽게 수정하자.  
- 오랫동안 소프트웨어 개발이란 무언가 '추가'하는 과정으로 여겼다.
- 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.

### 오래 걸리는 리팩터링
- 예컨대 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다.
- 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다.(이 전략을 추상화로 갈아타기라 한다.)

### 코드 리뷰에 리팩터링 활용하기
- 리팩토링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움이 된다.
- 내가 경험한 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것이다. 이렇게 하면 자연스럽게 짝 프로그래밍이 된다.

### 관라자에게는 뭐라고 말해야 할까?
- 관리자와 고객이 '리팩터링은 누적된 오류를 잡는 일이거나, 혹은 가치 있는 기능을 만들어내지 못하는 작업'이라고 오해하여 리팩터링이 금기어가 돼버린 조직도 있었다.
- 물론 기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강상태가 생산성에 미치는 영향을 모른다. 이런 상황에 있는 이들에게는 "리팩터링한다고 말하지 말라"고 조언하겠다.
- 프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다. 내 경험상 리팩터링하면 소프트웨어를 빠르게 만드는 데 아주 효과적이다.
- 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.

### 리팩터링하지 말아야 할 때
- 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
- 리팩터링하는 것보다 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다. 직접 해보기 전에는 어느 쪽이 쉬운지 알 수 없지만 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야 한다.


## 리픽터링시 고려할 문제
무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다. 리팩토링에 딸려오는 문제도 엄연히 있기에 이런 문제가 언제 발생하고, 어떻게 대처해야 할지를 반드시 알고 있어야 한다.

### 새 기능 개발 속도 저하
리팩터링으로 인해 진행이 느려진다고 생각하는 사람이 많다. 이 점이 실전에서 리팩터링을 적용하는 데 가장 큰 걸림돌인 것 같다.

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

- 건강한 코드의 위력을 경험해보지 않고서는 코드베이스가 건강할 때와 허약할 때의 생산성 차이를 체감하기 어렵다. 코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있다.
- 리팩터링은 개발 기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다. 스스로 그렇게 인식하는 데 그치지 말고 다른 사람과 대화할 때도 이 점을 명심해야 한다. 
- 리팩터링하도록 이끄는 동력은 어디까지나 경제적인 효과에 있다.

### 코드 소유권


### 브랜치
- 기능 브랜치 방식에는 단점이 있다. 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 
- 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 주장하는 사람이 많다. 한편 나와 같은 사람들은 더 짧아야 한다고 주장한다. 지속적 통합(CI), 또는 TBD라고 한다
- 머지의 복잡도를 줄일 수 있어서 CI를 선호하기도 하지만, 가장 큰 이유는 리팩터링과 궁합이 아주 좋기 때문이다.
- 켄트 백이 CI와 리팩터링을 합쳐서 익스트림 프로그래밍을 만든 이유도 바로 두 기법의 궁합이 잘 맞기 때문이다.

### 테스팅
- 리팩터링의 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 점이다. 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 한다. 실수하더라도 재빨리 해결하면 문제가 되지 않으며, 원인을 못찾더라도 가장 최근에 정상 작동하던 상태로 되돌리면 된다.
- 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다는 뜻이다.


### 레거시 코드
- 내가 선호하는 방식은 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이다. 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력한다. 역시 캠핑 규칙에 따라 처음 왔을 때보다 깨끗하게 치우는 것이다.
- 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 코드를 훑는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이니 당연히 이렇게 해야 한다.

### 데이터베이스
- 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 좋다는 점에서 다른 리팩터링과 다르다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다.

## 리팩터링과 소프트웨어 개발 프로세스
- 참고로 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)라고 한다.


## 리팩터링과 성능
- 리팩터링하면 소프트웨어가 느려질 수 있다는 것 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.
- 하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.

### 빠른 소프트웨어를 만드는 세 가지 방법
- 가장 엄격한 방법은 시간 예산 분배 방식
- 끊임없이 관심을 기울이는 것
